<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Overhead Ratio Visual Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: light;
      font-family: "Inter", "Segoe UI", sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1f2933;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    h1,
    h2,
    p {
      margin: 0;
    }

    .app {
      display: grid;
      grid-template-columns: minmax(320px, 420px) minmax(0, 1fr);
      gap: 24px;
      padding: 24px;
      height: 100vh;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
      padding-right: 8px;
    }

    .sidebar__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .sidebar__header h1 {
      font-size: 20px;
      font-weight: 600;
    }

    .sidebar__header p {
      font-size: 14px;
      color: var(--muted);
      margin-top: 6px;
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }

    .card h2 {
      font-size: 16px;
      margin-bottom: 8px;
    }

    .card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }

    .card__header h2 {
      margin-bottom: 0;
    }

    .card__hint {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 16px;
    }

    .grid {
      display: grid;
      gap: 12px;
    }

    .grid--uploads {
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .counts-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    .counts-table th,
    .counts-table td {
      text-align: left;
      padding: 4px 6px;
      vertical-align: top;
    }

    .counts-table td {
      text-align: right;
    }

    .counts-table__label {
      display: block;
      font-size: 13px;
      line-height: 1.2;
      color: var(--text);
      word-break: break-word;
    }

    .counts-table__input {
      width: 72px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 14px;
      text-align: right;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
    }

    .field--row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
      padding: 4px 6px;
    }

    .field span {
      min-height: 32px;
      display: flex;
      align-items: center;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .field input {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 14px;
    }

    .field--row input {
      width: 72px;
      text-align: right;
    }

    .counts-divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0 8px;
    }

    .upload {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      padding: 12px;
      border-radius: 12px;
      border: 1px dashed var(--border);
      background: #f8fafc;
    }

    .upload__header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upload__label {
      flex: 1 1 140px;
      min-width: 0;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 13px;
    }

    .upload input[type="file"] {
      font-size: 12px;
    }

    .upload__footer {
      display: flex;
      width: 100%;
    }

    .upload__footer button {
      width: 100%;
    }

    .preview {
      height: 80px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background-color: #f9fafb;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .actions__export {
      display: grid;
      gap: 8px;
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: var(--accent);
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: #111827;
    }

    button.ghost {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 12px;
    }

    button.ghost--danger {
      color: #b91c1c;
      border-color: #fecaca;
    }

    button.ghost--danger:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .export-status {
      display: none;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .export-status.is-active {
      display: flex;
    }

    .export-status__header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .export-status__message {
      font-weight: 500;
    }

    .export-status__details {
      margin: 0;
      padding-left: 16px;
      font-size: 11px;
      color: #8b95a5;
      display: grid;
      gap: 4px;
    }

    .export-status__bar {
      position: relative;
      flex: 1;
      height: 6px;
      border-radius: 999px;
      background: #e5e7eb;
      overflow: hidden;
    }

    .export-status__bar::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(37, 99, 235, 0.2), rgba(37, 99, 235, 0.9), rgba(37, 99, 235, 0.2));
      transform: translateX(-100%);
      animation: export-progress 1.2s infinite;
    }

    @keyframes export-progress {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .preview-pane {
      background: var(--card);
      border-radius: 20px;
      padding: 24px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .preview-pane__header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .preview-pane__header h2 {
      font-size: 18px;
    }

    .preview-pane__header p {
      font-size: 13px;
      color: var(--muted);
    }

    .figure {
      background: #fffdfa;
      border-radius: 18px;
      padding: 24px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 600px;
      justify-content: flex-start;
    }

    .figure__above {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 20px;
      align-items: stretch;
      min-height: 0;
      padding-bottom: 4px;
    }

    .figure__column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      height: 100%;
    }

    .figure__column-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      text-align: center;
      min-height: 32px;
      max-width: 160px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.2;
    }

    .figure__icon-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      align-items: center;
      margin-top: 8px;
    }

    .figure__below .figure__icon-grid {
      margin-top: 0;
    }

    .figure__above .figure__icon-grid {
      flex: 1;
      justify-content: flex-end;
    }

    .figure__icon-row {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .figure__line {
      height: 3px;
      background: #111827;
      border-radius: 999px;
      margin: 0 8px;
    }

    .figure__below {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 20px;
      padding-top: 4px;
      align-items: start;
      justify-items: center;
    }

    .figure__below .figure__column-title {
      margin-top: 8px;
    }

    .icon-card {
      width: 70px;
      height: 70px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      border: 1px solid var(--border);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.06);
    }

    .icon-card img {
      width: 60px;
      height: 60px;
      object-fit: contain;
    }

    @media (max-width: 1100px) {
      .app {
        grid-template-columns: 1fr;
        height: auto;
      }

      .preview-pane {
        min-height: 500px;
      }
    }
  </style>

  <!-- FIX: Load the BROWSER BUNDLE build so writeFile works reliably in GitHub Pages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PptxGenJS/3.12.0/pptxgen.bundle.min.js"></script>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <header class="sidebar__header">
        <div>
          <h1>Overhead Ratio Visual Builder</h1>
          <p>Create the ratio graphic with icons above and below the line.</p>
        </div>
        <button class="ghost" id="clearDraft" type="button">Clear Local Draft</button>
      </header>

      <section class="card">
        <h2>Above the Line Counts</h2>
        <p class="card__hint">Choose how many images appear in each category above the line.</p>
        <div id="counts-above"></div>
        <div class="counts-divider" role="presentation"></div>
        <label class="field field--row">
          <span>Rows (above the line)</span>
          <input type="number" min="1" value="1" id="rows-above">
        </label>
      </section>

      <section class="card">
        <h2>Below the Line Counts</h2>
        <p class="card__hint">Choose how many images appear in each category below the divider.</p>
        <div id="counts-below"></div>
        <div class="counts-divider" role="presentation"></div>
        <label class="field field--row">
          <span>Rows (below the line)</span>
          <input type="number" min="1" value="2" id="rows-below">
        </label>
      </section>

      <section class="card">
        <div class="card__header">
          <h2>Image Library &amp; Labels</h2>
          <button class="ghost" id="add-category" type="button">Add Label</button>
        </div>
        <p class="card__hint">Upload images and edit labels together. Add or remove categories as needed.</p>
        <div class="grid grid--uploads" id="category-library"></div>
      </section>

      <section class="card">
        <h2>Actions</h2>
        <div class="actions">
          <div class="actions__export">
            <button id="exportPpt" class="secondary" type="button">Export to PowerPoint</button>
            <div class="export-status" id="exportStatus">
              <div class="export-status__header">
                <span class="export-status__message" id="exportStatusMessage">Exporting…</span>
                <div class="export-status__bar" role="progressbar" aria-valuetext="Exporting"></div>
              </div>
              <ul class="export-status__details" id="exportStatusDetails"></ul>
            </div>
          </div>
        </div>
      </section>
    </aside>

    <main class="preview-pane">
      <header class="preview-pane__header">
        <h2>Live Output</h2>
        <p>Aligned layout rendered from your settings.</p>
      </header>
      <section class="figure" id="figure">
        <div class="figure__above" id="figure-above"></div>
        <div class="figure__line"></div>
        <div class="figure__below" id="figure-below"></div>
      </section>
    </main>
  </div>

  <script>
    const svgToDataUrl = (svg) => {
      const encoded = btoa(unescape(encodeURIComponent(svg)));
      return `data:image/svg+xml;base64,${encoded}`;
    };

    const defaultSvg = `
      <svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <rect width="120" height="120" rx="18" fill="#EEF2F7" />
        <path d="M35 70c0-12 10-22 22-22s22 10 22 22" stroke="#B3BCCB" stroke-width="6" fill="none"/>
        <circle cx="57" cy="42" r="14" fill="#B3BCCB"/>
      </svg>
    `;

    const defaultImage = svgToDataUrl(defaultSvg);
    const defaultCategories = [
      { id: 'manufacturing-omr', label: 'Manufacturing OMR', counts: { above: 3, below: 0 }, image: defaultImage },
      { id: 'install-omr', label: 'Install OMR', counts: { above: 3, below: 0 }, image: defaultImage },
      { id: 'engineering', label: 'Engineering', counts: { above: 3, below: 0 }, image: defaultImage },
      { id: 'plf', label: 'PL&F', counts: { above: 2, below: 0 }, image: defaultImage },
      { id: 'safety', label: 'Safety', counts: { above: 2, below: 0 }, image: defaultImage },
      { id: 'mfg-install', label: 'Manufacturing & Install Engineers', counts: { above: 0, below: 10 }, image: defaultImage }
    ];

    const state = {
      categories: structuredClone(defaultCategories),
      rowsAbove: 1,
      rowsBelow: 2
    };

    const draftKey = 'overhead-ratio-draft-v1';

    const normalizeImageData = (image) => {
      if (!image) return defaultImage;
      if (typeof image !== 'string') return defaultImage;
      if (image.startsWith('data:image/svg+xml') && !image.includes('base64,')) {
        const rawSvg = decodeURIComponent(image.split(',')[1] || '');
        return svgToDataUrl(rawSvg);
      }
      return image;
    };

    const normalizeCategory = (category) => ({
      id: category.id || `category-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
      label: category.label || 'New Category',
      counts: {
        above: Number(category.counts?.above ?? 0),
        below: Number(category.counts?.below ?? 0)
      },
      image: normalizeImageData(category.image) || defaultImage
    });

    const getCategoryImage = (category) => normalizeImageData(category.image) || defaultImage;

    const saveDraft = () => {
      const draft = {
        categories: state.categories,
        rowsAbove: state.rowsAbove,
        rowsBelow: state.rowsBelow
      };
      localStorage.setItem(draftKey, JSON.stringify(draft));
    };

    const loadDraft = () => {
      const raw = localStorage.getItem(draftKey);
      if (!raw) return;
      try {
        const draft = JSON.parse(raw);
        if (draft?.categories?.length) {
          state.categories = draft.categories.map(normalizeCategory);
          state.rowsAbove = Number(draft.rowsAbove ?? 1);
          state.rowsBelow = Number(draft.rowsBelow ?? 2);
          return;
        }

        if (draft?.counts || draft?.labels || draft?.images) {
          const mapped = structuredClone(defaultCategories).map((category) => {
            if (draft?.labels) {
              const labelMap = {
                'manufacturing-omr': draft.labels.manufacturing,
                'install-omr': draft.labels.install,
                engineering: draft.labels.engineering,
                plf: draft.labels.plf,
                safety: draft.labels.safety,
                'mfg-install': draft.labels.below
              };
              category.label = labelMap[category.id] ?? category.label;
            }

            if (draft?.counts) {
              const countMap = {
                'manufacturing-omr': draft.counts.manufacturing,
                'install-omr': draft.counts.install,
                engineering: draft.counts.engineering,
                plf: draft.counts.plf,
                safety: draft.counts.safety,
                'mfg-install': draft.counts.below
              };
              if (category.id === 'mfg-install') {
                category.counts.below = Number(countMap[category.id] ?? category.counts.below);
              } else {
                category.counts.above = Number(countMap[category.id] ?? category.counts.above);
              }
            }

            if (draft?.images) {
              const imageMap = {
                'manufacturing-omr': draft.images.manufacturing,
                'install-omr': draft.images.install,
                engineering: draft.images.engineering,
                plf: draft.images.plf,
                safety: draft.images.safety,
                'mfg-install': draft.images.below
              };
              category.image = normalizeImageData(imageMap[category.id]) ?? category.image;
            }
            return category;
          });

          state.categories = mapped;
          state.rowsAbove = Number(draft.counts?.rowsAbove ?? 1);
          state.rowsBelow = Number(draft.counts?.rowsBelow ?? 2);
        }
      } catch (error) {
        console.warn('Draft load failed', error);
      }
    };

    const createIcon = (src, label) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'icon-card';
      const img = document.createElement('img');
      img.src = src;
      img.alt = label;
      wrapper.appendChild(img);
      return wrapper;
    };

    const getCategoryLabel = (category) => category.label?.trim() || 'Untitled';

    const buildIconRows = (count, rows, iconSrc, label, fillFromBottom) => {
      const safeRows = Math.max(1, rows);
      const iconsPerRow = Math.max(1, Math.ceil(count / safeRows));
      const rowElements = Array.from({ length: safeRows }, () => {
        const row = document.createElement('div');
        row.className = 'figure__icon-row';
        return row;
      });

      for (let i = 0; i < count; i += 1) {
        const baseRow = Math.floor(i / iconsPerRow);
        const rowIndex = fillFromBottom ? safeRows - 1 - baseRow : baseRow;
        rowElements[rowIndex].appendChild(createIcon(iconSrc, label));
      }

      return rowElements;
    };

    const renderCountsSection = (containerId, position) => {
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      const table = document.createElement('table');
      table.className = 'counts-table';

      state.categories.forEach((category) => {
        const row = document.createElement('tr');
        const labelCell = document.createElement('th');
        const label = document.createElement('span');
        label.className = 'counts-table__label';
        label.textContent = getCategoryLabel(category);
        labelCell.appendChild(label);

        const inputCell = document.createElement('td');
        const input = document.createElement('input');
        input.className = 'counts-table__input';
        input.type = 'number';
        input.min = '0';
        input.value = category.counts[position] ?? 0;
        input.addEventListener('input', () => {
          category.counts[position] = Number(input.value || 0);
          renderFigure();
          saveDraft();
        });
        inputCell.appendChild(input);

        row.appendChild(labelCell);
        row.appendChild(inputCell);
        table.appendChild(row);
      });
      container.appendChild(table);
    };

    const renderCategoryLibrary = () => {
      const container = document.getElementById('category-library');
      container.innerHTML = '';
      const disableRemove = state.categories.length === 1;

      state.categories.forEach((category) => {
        const card = document.createElement('div');
        card.className = 'upload';

        const header = document.createElement('div');
        header.className = 'upload__header';

        const labelInput = document.createElement('input');
        labelInput.type = 'text';
        labelInput.value = category.label;
        labelInput.className = 'upload__label';
        labelInput.addEventListener('input', () => {
          category.label = labelInput.value;
          renderCountsSection('counts-above', 'above');
          renderCountsSection('counts-below', 'below');
          renderFigure();
          saveDraft();
        });

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'ghost ghost--danger';
        removeButton.textContent = 'Remove';
        removeButton.disabled = disableRemove;
        removeButton.addEventListener('click', () => {
          state.categories = state.categories.filter((item) => item.id !== category.id);
          renderControls();
          renderFigure();
          saveDraft();
        });

        header.appendChild(labelInput);

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.addEventListener('change', (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (loadEvent) => {
            const result = loadEvent.target.result;
            category.image = result;
            preview.style.backgroundImage = `url(${result})`;
            renderFigure();
            saveDraft();
          };
          reader.readAsDataURL(file);
        });

        const preview = document.createElement('div');
        preview.className = 'preview';
        preview.style.backgroundImage = `url(${getCategoryImage(category)})`;

        const footer = document.createElement('div');
        footer.className = 'upload__footer';
        footer.appendChild(removeButton);

        card.appendChild(header);
        card.appendChild(fileInput);
        card.appendChild(preview);
        card.appendChild(footer);
        container.appendChild(card);
      });
    };

    const renderControls = () => {
      renderCountsSection('counts-above', 'above');
      renderCountsSection('counts-below', 'below');
      renderCategoryLibrary();

      const rowsAboveInput = document.getElementById('rows-above');
      const rowsBelowInput = document.getElementById('rows-below');
      rowsAboveInput.value = state.rowsAbove;
      rowsBelowInput.value = state.rowsBelow;

      rowsAboveInput.oninput = () => {
        state.rowsAbove = Math.max(1, Number(rowsAboveInput.value || 1));
        renderFigure();
        saveDraft();
      };

      rowsBelowInput.oninput = () => {
        state.rowsBelow = Math.max(1, Number(rowsBelowInput.value || 1));
        renderFigure();
        saveDraft();
      };
    };

    const renderAbove = () => {
      const container = document.getElementById('figure-above');
      container.innerHTML = '';
      const rowsAbove = state.rowsAbove;
      const categories = state.categories.filter((category) => Number(category.counts?.above || 0) > 0);

      categories.forEach((category) => {
        const column = document.createElement('div');
        column.className = 'figure__column';

        const title = document.createElement('div');
        title.className = 'figure__column-title';
        const label = getCategoryLabel(category);
        title.textContent = label;
        column.appendChild(title);

        const count = Number(category.counts?.above || 0);
        const iconGrid = document.createElement('div');
        iconGrid.className = 'figure__icon-grid';
        const iconRows = buildIconRows(count, rowsAbove, getCategoryImage(category), label, true);
        iconRows.forEach((row) => iconGrid.appendChild(row));

        column.appendChild(iconGrid);
        container.appendChild(column);
      });
    };

    const renderBelow = () => {
      const container = document.getElementById('figure-below');
      container.innerHTML = '';
      const rowsBelow = state.rowsBelow;
      const categories = state.categories.filter((category) => Number(category.counts?.below || 0) > 0);

      categories.forEach((category) => {
        const column = document.createElement('div');
        column.className = 'figure__column';

        const count = Number(category.counts?.below || 0);
        const iconGrid = document.createElement('div');
        iconGrid.className = 'figure__icon-grid';
        const label = getCategoryLabel(category);
        const iconRows = buildIconRows(count, rowsBelow, getCategoryImage(category), label, false);
        iconRows.forEach((row) => iconGrid.appendChild(row));

        column.appendChild(iconGrid);

        const title = document.createElement('div');
        title.className = 'figure__column-title';
        title.textContent = label;
        column.appendChild(title);

        container.appendChild(column);
      });
    };

    const renderFigure = () => {
      renderAbove();
      renderBelow();
      saveDraft();
    };

    // FIX: Prefer loading the BUNDLE build for browsers.
    // (The bundle includes the pieces needed for writeFile/download.)
    const pptxScriptSources = [
      'https://cdnjs.cloudflare.com/ajax/libs/PptxGenJS/3.12.0/pptxgen.bundle.min.js',
      'https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.min.js',
      'https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.bundle.min.js',

      // Fallbacks (non-bundle) in case a CDN misbehaves:
      'https://cdnjs.cloudflare.com/ajax/libs/PptxGenJS/3.12.0/pptxgen.min.js',
      'https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.min.js',
      'https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.min.js'
    ];
    let pptxScriptPromise = null;

    const loadPptxGen = () => {
      if (typeof PptxGenJS !== 'undefined') {
        return Promise.resolve();
      }

      if (pptxScriptPromise) {
        return pptxScriptPromise;
      }

      pptxScriptPromise = new Promise((resolve, reject) => {
        let index = 0;

        const tryNext = () => {
          if (typeof PptxGenJS !== 'undefined') {
            resolve();
            return;
          }

          if (index >= pptxScriptSources.length) {
            reject(new Error('PptxGenJS failed to load.'));
            return;
          }

          const script = document.createElement('script');
          script.src = pptxScriptSources[index];
          script.async = true;
          script.onload = () => {
            if (typeof PptxGenJS !== 'undefined') {
              resolve();
              return;
            }
            index += 1;
            tryNext();
          };
          script.onerror = () => {
            index += 1;
            tryNext();
          };
          document.head.appendChild(script);
        };

        tryNext();
      });

      return pptxScriptPromise;
    };

    const updateExportStatus = (message, detailItems = []) => {
      const exportStatus = document.getElementById('exportStatus');
      const exportMessage = document.getElementById('exportStatusMessage');
      const exportDetails = document.getElementById('exportStatusDetails');
      if (!exportStatus || !exportMessage || !exportDetails) return;
      exportMessage.textContent = message;
      exportDetails.innerHTML = '';
      detailItems.forEach((detail) => {
        const item = document.createElement('li');
        item.textContent = detail;
        exportDetails.appendChild(item);
      });
      exportStatus.querySelector('.export-status__bar')?.setAttribute('aria-valuetext', message);
    };

    const waitForFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));

    const withTimeout = (promise, ms, message) => Promise.race([
      promise,
      new Promise((_, reject) => setTimeout(() => reject(new Error(message)), ms))
    ]);

    const exportToPpt = async () => {
      const exportStatus = document.getElementById('exportStatus');
      const exportButton = document.getElementById('exportPpt');
      exportButton.disabled = true;
      exportButton.textContent = 'Exporting...';
      exportStatus?.classList.add('is-active');

      try {
        updateExportStatus('Loading export tools…', ['Fetching the PowerPoint library.']);
        await loadPptxGen();

        // Extra guard: if a non-bundle build loaded and the environment is missing download helpers,
        // fail with a useful error instead of a vague rejection.
        if (typeof PptxGenJS === 'undefined') {
          throw new Error('PptxGenJS is not available after loading.');
        }

        updateExportStatus('Preparing the slide…', [
          'Initializing the PowerPoint document.',
          'Sizing the slide layout.',
          'Calculating icon positions.'
        ]);
        await waitForFrame();

        updateExportStatus('Building the slide canvas…', [
          'Creating the presentation object.',
          'Setting slide layout to wide.'
        ]);
        const pptx = new PptxGenJS();
        pptx.layout = 'LAYOUT_WIDE';
        await waitForFrame();

        updateExportStatus('Building the slide canvas…', [
          'Presentation ready.',
          'Creating a new slide.'
        ]);
        const slide = pptx.addSlide();
        await waitForFrame();

        const titleText = 'Overhead Ratio Visual';
        updateExportStatus('Building the slide canvas…', [
          'Slide created.',
          `Adding the title (${titleText.length} characters).`,
          'Applying title font and color.'
        ]);
        slide.addText(titleText, { x: 0.6, y: 0.2, w: 12.3, h: 0.4, fontSize: 18, bold: true, color: '1F2933' });

        const slideWidth = 13.3;
        const leftPadding = 0.6;
        const rightPadding = 0.6;
        const usableWidth = slideWidth - leftPadding - rightPadding;
        const columnWidth = usableWidth / Math.max(1, state.categories.length);
        const iconSize = 0.7;
        const iconGap = 0.1;
        const aboveRows = state.rowsAbove;
        const belowRows = state.rowsBelow;
        const lineY = 3.4;
        const aboveBottomPadding = 0.2;
        const belowTopPadding = 0.3;
        const aboveRowHeight = aboveRows * (iconSize + iconGap) - iconGap;
        const aboveIconsTop = lineY - aboveBottomPadding - aboveRowHeight;

        updateExportStatus('Calculating layout metrics…', [
          `Slide width: ${slideWidth} in.`,
          `Columns: ${state.categories.length}.`,
          `Above rows: ${aboveRows}, below rows: ${belowRows}.`
        ]);
        await waitForFrame();

        updateExportStatus('Placing icons above the line…', [
          `${state.categories.length} categories detected.`,
          `Icon size: ${iconSize} in.`,
          `Gap: ${iconGap} in.`
        ]);
        await waitForFrame();

        for (const [index, category] of state.categories.entries()) {
          const columnX = leftPadding + columnWidth * index;
          const label = getCategoryLabel(category);
          const count = Number(category.counts?.above || 0);
          const iconsPerRow = Math.max(1, Math.ceil(count / aboveRows));
          updateExportStatus('Placing icons above the line…', [
            `Category ${index + 1} of ${state.categories.length}: ${label}.`,
            `Icons above: ${count}.`,
            `Icons per row: ${iconsPerRow}.`
          ]);
          await waitForFrame();

          slide.addText(label, {
            x: columnX,
            y: 0.8,
            w: columnWidth,
            h: 0.3,
            fontSize: 12,
            align: 'center',
            color: '4B5563'
          });

          for (let i = 0; i < count; i += 1) {
            const row = aboveRows - 1 - Math.floor(i / iconsPerRow);
            const col = i % iconsPerRow;
            const x = columnX + col * (iconSize + iconGap) + (columnWidth - iconsPerRow * (iconSize + iconGap) + iconGap) / 2;
            const y = aboveIconsTop + row * (iconSize + iconGap);
            slide.addImage({ data: getCategoryImage(category), x, y, w: iconSize, h: iconSize });
          }
        }

        updateExportStatus('Drawing the divider line…', [
          'Adding the center line.',
          `Divider position: ${lineY} in.`
        ]);
        await waitForFrame();

        slide.addShape(pptx.ShapeType.line, {
          x: leftPadding,
          y: lineY,
          w: usableWidth,
          h: 0,
          line: { color: '111827', width: 2 }
        });

        const belowCategories = state.categories.filter((category) => Number(category.counts?.below || 0) > 0);
        const belowColumnWidth = usableWidth / Math.max(1, belowCategories.length);

        updateExportStatus('Filtering below-line categories…', [
          `${belowCategories.length} categories below the line.`,
          `Columns below: ${belowCategories.length || 1}.`
        ]);
        await waitForFrame();

        updateExportStatus('Placing icons below the line…', [
          `${belowCategories.length} categories below the line.`,
          `Icon size: ${iconSize} in.`,
          `Gap: ${iconGap} in.`
        ]);
        await waitForFrame();

        for (const [index, category] of belowCategories.entries()) {
          const columnX = leftPadding + belowColumnWidth * index;
          const count = Number(category.counts?.below || 0);
          const iconsPerRow = Math.max(1, Math.ceil(count / belowRows));
          updateExportStatus('Placing icons below the line…', [
            `Category ${index + 1} of ${belowCategories.length}: ${getCategoryLabel(category)}.`,
            `Icons below: ${count}.`,
            `Icons per row: ${iconsPerRow}.`
          ]);
          await waitForFrame();

          for (let i = 0; i < count; i += 1) {
            const row = Math.floor(i / iconsPerRow);
            const col = i % iconsPerRow;
            const x = columnX + col * (iconSize + iconGap) + (belowColumnWidth - iconsPerRow * (iconSize + iconGap) + iconGap) / 2;
            const y = lineY + belowTopPadding + row * (iconSize + iconGap);
            slide.addImage({ data: getCategoryImage(category), x, y, w: iconSize, h: iconSize });
          }

          const belowLabelY = lineY + belowTopPadding + belowRows * (iconSize + iconGap) + 0.1;
          slide.addText(getCategoryLabel(category), {
            x: columnX,
            y: belowLabelY,
            w: belowColumnWidth,
            h: 0.3,
            fontSize: 10,
            align: 'center',
            color: '4B5563'
          });
        }

        updateExportStatus('Generating PowerPoint file…', ['Packaging slides and assets.', 'This can take a few seconds.']);
        await waitForFrame();

        // writeFile() is the step that used to fail on GitHub Pages when the non-bundle build was loaded.
        await withTimeout(
          pptx.writeFile({ fileName: 'overhead-ratio-visual.pptx' }),
          30000,
          'PowerPoint export timed out.'
        );
      } catch (error) {
        console.error('PowerPoint export failed', error);
        updateExportStatus('Export failed.', [
          `Error: ${error.message || 'Unknown error'}.`,
          'Please try again.',
          'If the issue persists, refresh the page.'
        ]);
        alert('PowerPoint export failed. Please try again.');
      } finally {
        exportButton.disabled = false;
        exportButton.textContent = 'Export to PowerPoint';
        exportStatus?.classList.remove('is-active');
      }
    };

    document.getElementById('exportPpt').addEventListener('click', exportToPpt);
    document.getElementById('add-category').addEventListener('click', () => {
      state.categories.push(normalizeCategory({ label: 'New Category', counts: { above: 0, below: 0 }, image: defaultImage }));
      renderControls();
      renderFigure();
      saveDraft();
    });
    document.getElementById('clearDraft').addEventListener('click', () => {
      localStorage.removeItem(draftKey);
      window.location.reload();
    });

    loadDraft();
    renderControls();
    renderFigure();
  </script>
</body>
</html>
